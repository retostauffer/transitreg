% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transitreg.R
\name{transitreg}
\alias{transitreg}
\alias{prodist.transitreg}
\alias{newresponse.transitreg}
\alias{logLik.transitreg}
\title{Transition Models Estimation}
\usage{
transitreg(
  formula,
  data,
  subset,
  na.action,
  engine = "bam",
  breaks = NULL,
  censored = c("uncensored", "left", "right", "both"),
  model = TRUE,
  ncores = NULL,
  verbose = FALSE,
  ...
)

\method{prodist}{transitreg}(object, newdata = NULL, ...)

\method{newresponse}{transitreg}(object, newdata = NULL, ...)

\method{logLik}{transitreg}(object, newdata = NULL, ...)
}
\arguments{
\item{formula}{Object of class \code{transitreg}.}

\item{data}{A data frame containing the data for modeling.}

\item{subset}{An optional vector specifying a subset of observations to be used in the
fitting process.}

\item{na.action}{A function that determines how \code{NA} values in the data should be handled.}

\item{engine}{Character string specifying the estimation engine. Options include
\code{"bam"}, \code{"gam"}, \code{"nnet"}, or \code{"glmnet"} (experimental).
Default is \code{"bam"}.}

\item{breaks}{Controls the splitting of continuous responses into intervals to mimic a
count response. If a single number is provided, equidistant intervals are used. If a
numeric vector is provided, it is used directly as the breakpoints. This argument is
critical for continuous responses.}

\item{censored}{character, or one of \code{"uncensored"} (default), \code{"left"}, \code{"right"}, or \code{"both"}.
Specifies if the distribution is uncensored or censored on one or both ends.}

\item{model}{Logical value indicating whether the model frame should be included in
the return object.}

\item{ncores}{\code{NULL} (default) or single numeric. See 'OpenMP' for more information.}

\item{verbose}{Logical value indicating whether progress and diagnostic messages
should be printed. Default is \code{FALSE}.}

\item{\dots}{Additional arguments to be passed to the estimation engine.}

\item{object}{Transition model, object of class \code{transitreg}.}

\item{newdata}{An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.}
}
\value{
An object of class \code{"transitreg"}, which includes the following components:
\itemize{
\item Fitted model results compatible with \pkg{mgcv}-style outputs.
\item Methods for \code{plot}, \code{summary}, \code{residuals}, and \code{predict}.
\item Model diagnostics and transformation details.
}

See \code{\link[=transitreg_detect_cores]{transitreg_detect_cores()}} for some more details.
}
\description{
Fits transition models to count or continuous response data. The method leverages
transition probabilities to construct flexible probabilistic models without assuming
a fixed distribution for the response variable. Estimation relies on \pkg{mgcv}
infrastructure for GLM-type binary modeling.
}
\details{
The function transforms the input data using \code{\link[=transitreg_tmf]{transitreg_tmf()}} to a format
compatible with transition models. Estimation relies on binary GLM-type techniques
to model conditional transition probabilities. Note that the \code{theta} variable, representing
the current transition level, must be included in the model by the user, please
see the examples. Additional transition-specific covariates, such as those addressing excess
zeros, can be included by adding \code{theta0}, \code{theta1}, etc., to the formula.

For continuous responses, the \code{breaks} argument specifies the intervals for
discretizing the response, enabling the application of count-based transition models.
}
\section{OpenMP}{

For improved performance \code{"transitreg"} is partially implemented in \code{C}, making
use of the OpenMP library for parallelization. The argument \code{ncores} allows
the user to control how many cores to be used for the \code{C} functions shipped
with this package. By default, the number of cores will be detected
automatically (\code{ncores = NULL}). The following rules are applied:
\itemize{
\item If OpenMP is not available, the number of cores is set to \code{1L} in all cases.
\item If \code{ncores = NULL} the total number of cores (\code{N}) is detected
automatically, and \code{ncores} is set to \code{N - 2L}.
\item If \code{ncores < 1L}, one core will be used (single-core processing).
\item If \code{ncores > 1L} all available cores will be utilized.
}
}

\examples{
## Example 1: Count data.
set.seed(123)
n <- 1000
x <- runif(n, -3, 3)
y <- rpois(n, exp(2 + sin(x)))

## Fit transition count response model.
b <- transitreg(y ~ s(theta) + s(x))

## GAM summary.
summary(b)

## GAM coefficients
coef(b)

## Effect plots.
plot(b)

## Plotting hanging rootogram, quantile residuals, and
## a probability integral transform (PIT) histogram.
plot(b, which = c("rootogram", "qqrplot", "pithist", "wormplot"))

## Predictions and plotting.
nd <- data.frame(x = seq(-3, 3, length = 100))
fit <- cbind(
  "97.5\%"  = predict(b, nd, type = "quantile", p = 1 - 0.05/2),
  "median" = predict(b, nd, type = "quantile", p = 0.5),
  "2.5\%"   = predict(b, nd, type = "quantile", p = 0.05/2),
  "mode"   = predict(b, nd, type = "mode"),
  "mean"   = predict(b, nd, type = "mean")
)

## Plot data and fitted counts.
plot(y ~ x, pch = 16, col = rgb(0.1, 0.1, 0.1, alpha = 0.4))
matplot(nd$x, fit, type = "l", add = TRUE, lwd = 2,
       col = c(4, 4, 4, 2, 3), lty = c(2, 1, 2, 1, 1))
legend("topleft", legend = colnames(fit),
       col = c(4, 4, 4, 2, 3), lty = c(2, 1, 2, 1, 1))

## Visualizing three predicted distributions via Transitreg distributions
idx <- c(25, 50, 75)
d3 <- Transition(predict(b, nd[idx, , drop = FALSE], type = "tp"), breaks = seq.int(0, b$bins))

par(ask = TRUE)
plot(d3)
abline(v = predict(b, nd[idx, , drop = FALSE], type = "mode"), col = 1:3, lty = 3)
plot(d3, tp = TRUE) # add transition probabilities
abline(v = predict(b, nd[idx, , drop = FALSE], type = "mode"), col = 1:3, lty = 3)

plot(d3, cdf = TRUE)
plot(d3, cdf = TRUE, tp = TRUE) # add transition probabilities


## Example 2: Continuous response.
set.seed(123)
n <- 1000
x <- runif(n, -3, 3)
y <- sin(x) + rnorm(n, sd = exp(-1 + cos(x)))

## Fit model with continuous response.
b <- transitreg(y ~ s(theta) + s(x) + te(x, theta), breaks = 200)

## Diagnostic plots
plot(b, which = c("rootogram", "qqrplot", "pithist", "wormplot"))

## Predictions and plotting
nd <- data.frame(x = seq(-3, 3, length = 100))
fit <- cbind(
  "97.5\%"  = predict(b, nd, type = "quantile", p = 1 - 0.05/2),
  "median" = predict(b, nd, type = "quantile", p = 0.5),
  "2.5\%"   = predict(b, nd, type = "quantile", p = 0.05/2),
  "mode"   = predict(b, nd, type = "mode")
)

## Plot data and fitted curves.
plot(y ~ x, pch = 16, col = rgb(0.1, 0.1, 0.1, alpha = 0.4))
matplot(nd$x, fit, type = "l", add = TRUE, lwd = 2,
       col = c(4, 4, 4, 2), lty = c(2, 1, 2, 1))
legend("topleft", legend = colnames(fit),
       col = c(4, 4, 4, 2), lty = c(2, 1, 2, 1))

## Visualizing 5 randomly selected fitted distributions
set.seed(6020)

par(ask = TRUE)
idx <- sample(seq_len(nrow(model.frame(b))), 5L)
plot(b[idx])
plot(b[idx], cdf = TRUE)
plot(b[idx], cdf = TRUE, tp = TRUE)


## Example 3: Count response with neural network.
set.seed(123)
n <- 1000
x <- runif(n, -3, 3)
y <- rpois(n, exp(2 + sin(x)))

## Fit NN transition count response model.
b <- transitreg(y ~ theta + x, engine = "nnet",
                size = 5, maxit = 1000, decay = 0.001)

## Predictions and plotting.
nd <- data.frame(x = seq(-3, 3, length = 100))
fit <- cbind(
  "97.5\%"  = predict(b, nd, type = "quantile", p = 1 - 0.05/2),
  "median" = predict(b, nd, type = "quantile", p = 0.5),
  "2.5\%"   = predict(b, nd, type = "quantile", p = 0.05/2),
  "mode"   = predict(b, nd, type = "mode")
)

## Plot data and fitted counts.
plot(y ~ x, pch = 16, col = rgb(0.1, 0.1, 0.1, alpha = 0.4))
matplot(nd$x, fit, type = "l", add = TRUE, lwd = 2,
       col = c(4, 4, 4, 2), lty = c(2, 1, 2, 1))
legend("topleft", legend = colnames(fit),
       col = c(4, 4, 4, 2), lty = c(2, 1, 2, 1))

## Visualizing 5 randomly selected fitted distributions
set.seed(2025)
idx <- sample(seq_len(nrow(model.frame(b))), 5L)

par(ask = TRUE)
plot(b[idx])
plot(b[idx], cdf = TRUE)
plot(b[idx], cdf = TRUE, tp = TRUE)

}
\seealso{
\code{\link[=transitreg_tmf]{transitreg_tmf()}}, \code{\link[mgcv:gam]{mgcv::gam()}}
}
\author{
Niki

Reto
}
\keyword{models}
\keyword{regression}
